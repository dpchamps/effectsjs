// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`transformEffects Transform proposed effects keywords into working JS async-parent-functions.js: async-parent-functions.js 1`] = `

const entry = () => {
  try{
      throw new Error('error')
  }handle default with (e){

  }
};

const asyncNotCaught = async () => {
    'use effects';
    entry();
};

const asyncCaught = async () => {
  try{
      'use effects'
      entry();
  }catch(e){
      // swallow error
  }
};

module.exports.test = ({it, expect, code}) => {
    it('Should await runtime root when parent function is async', async () => {
        expect(asyncNotCaught()).rejects.toThrow('error');
    });

    it('Should await runtime within a try/catch if parent function is async', () => {
        expect(asyncCaught()).resolves.toBeUndefined();
    });
};

      ↓ ↓ ↓ ↓ ↓ ↓

const entry = function*() {
  return yield withHandler(
    {
      *[__defaultEffectHandler__](e, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      }
    },
    (async function*() {
      throw new Error("error");
    })()
  );
};

const asyncNotCaught = async () => {
  return runProgram(
    (function*() {
      yield entry();
    })()
  );
};

const asyncCaught = async () => {
  try {
    await runProgram(
      (function*() {
        yield entry();
      })()
    );
  } catch (e) {
    // swallow error
  }
};

module.exports.test = ({ it, expect, code }) => {
  it("Should await runtime root when parent function is async", async () => {
    expect(asyncNotCaught()).rejects.toThrow("error");
  });
  it("Should await runtime within a try/catch if parent function is async", () => {
    expect(asyncCaught()).resolves.toBeUndefined();
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS captured-continuation-error-handling.js: captured-continuation-error-handling.js 1`] = `

const throwErrorHandler = 'throwErrorHandler';

const ThrowErrorEffect = () => ({type : throwErrorHandler});

const main = () => {
    'use effects';
    try{
        perform ThrowErrorEffect();
    }handle throwErrorHandler with (e){
        throw new Error('I am an error')
    }

};

module.exports.test = async ({describe, it, expect}) => {
    it('Should handle errors within effects', async () => {
        await expect(main()).rejects.toThrowError();
    })
};

      ↓ ↓ ↓ ↓ ↓ ↓

const throwErrorHandler = "throwErrorHandler";

const ThrowErrorEffect = () => ({
  type: throwErrorHandler
});

const main = () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[throwErrorHandler](e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  throw new Error("I am an error");
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          yield performEffect(ThrowErrorEffect());
        })()
      );
    })()
  );
};

module.exports.test = async ({ describe, it, expect }) => {
  it("Should handle errors within effects", async () => {
    await expect(main()).rejects.toThrowError();
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS composable-recall-statements.js: composable-recall-statements.js 1`] = `

const effectTypeA = 'typeA';
const effectTypeB = 'typeB';
const effectTypeC = 'typeC';
const effectTypeD = 'typeD';

const EffectA = () => ({type : effectTypeA});
const EffectB = () => ({type : effectTypeB});
const EffectC = () => ({type : effectTypeC});
const EffectD = (data) => ({type : effectTypeD, data});

const aHandler = () => {
  recall effectTypeA;
};

const bHandler = () => {
    recall effectTypeB;
};

const cHandler = () => {
  recall effectTypeC;
};

const main = (fn) => {
    try{
        return fn();
    }handle effectTypeA with (e) {
        aHandler();
    }handle effectTypeB with (e) {
        bHandler();
    }handle effectTypeC with (e) {
        cHandler();
    }handle effectTypeD with (e) {
        switch(e.data){
            case 1 : return aHandler();
            case 2 : return bHandler();
            case 3 : return cHandler();
            default : return recall "bazinga";
        }
    }
};

const performATest = () => {
    'use effects'
    main(() => {
       return perform EffectA();
    });
};

const performBTest = () => {
    'use effects'
    main(() => {
        return perform EffectB();
    });
};

const performCTest = () => {
    'use effects'
    main(() => {
        return perform EffectC();
    });
};

const performDTest = (input) => {
    'use effects';
    main(() => {
        return perform EffectD(input);
    })
};

const performAllTest = () => {
    'use effects'
    main(() => {
        return \`\${perform EffectA()}\${perform EffectB()}\${perform EffectC()}\`;
    });
};

module.exports.test = ({it, describe, expect, code}) => {
    describe('Single effect', () => {
        it('Should perform effect A', async () => {
            const result = await performATest();
            expect(result).toBe(effectTypeA);
        });

        it('Should perform effect B', async () => {
            const result = await performBTest();
            expect(result).toBe(effectTypeB);
        });

        it('Should perform effect C', async () => {
            const result = await performCTest();
            expect(result).toBe(effectTypeC);
        });

    });

    describe('Overlapping recall statements', () => {
        it('Should perform recall functions referenced in multiple places without cause', async () => {
            const resultA = await performDTest(1);
            const resultB = await performDTest(2);
            const resultC = await performDTest(3);
            const bazinga = await performDTest('bazinga');

            expect(resultA).toBe(effectTypeA);
            expect(resultB).toBe(effectTypeB);
            expect(resultC).toBe(effectTypeC);
            expect(bazinga).toBe('bazinga');
        });
    });

    it('Should handle all cases', async () => {
        const result = await performAllTest();

        expect(result).toBe(\`\${effectTypeA}\${effectTypeB}\${effectTypeC}\`);
    })
};

      ↓ ↓ ↓ ↓ ↓ ↓

const effectTypeA = "typeA";
const effectTypeB = "typeB";
const effectTypeC = "typeC";
const effectTypeD = "typeD";

const EffectA = () => ({
  type: effectTypeA
});

const EffectB = () => ({
  type: effectTypeB
});

const EffectC = () => ({
  type: effectTypeC
});

const EffectD = data => ({
  type: effectTypeD,
  data
});

const main = function*(fn) {
  return yield withHandler(
    {
      *[effectTypeA](e, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              const aHandler = () => {
                return stackResume(handler, effectTypeA)
                  .then(res)
                  .catch(rej);
              };

              aHandler();
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      },

      *[effectTypeB](e, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              const bHandler = () => {
                return stackResume(handler, effectTypeB)
                  .then(res)
                  .catch(rej);
              };

              bHandler();
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      },

      *[effectTypeC](e, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              const cHandler = () => {
                return stackResume(handler, effectTypeC)
                  .then(res)
                  .catch(rej);
              };

              cHandler();
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      },

      *[effectTypeD](e, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              const aHandler = () => {
                return stackResume(handler, effectTypeA)
                  .then(res)
                  .catch(rej);
              };

              const bHandler = () => {
                return stackResume(handler, effectTypeB)
                  .then(res)
                  .catch(rej);
              };

              const cHandler = () => {
                return stackResume(handler, effectTypeC)
                  .then(res)
                  .catch(rej);
              };

              switch (e.data) {
                case 1:
                  return aHandler();

                case 2:
                  return bHandler();

                case 3:
                  return cHandler();

                default:
                  return stackResume(handler, "bazinga")
                    .then(res)
                    .catch(rej);
              }
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      }
    },
    (async function*() {
      return yield fn();
    })()
  );
};

const performATest = () => {
  return runProgram(
    (function*() {
      yield main(function*() {
        return yield performEffect(yield EffectA());
      });
    })()
  );
};

const performBTest = () => {
  return runProgram(
    (function*() {
      yield main(function*() {
        return yield performEffect(yield EffectB());
      });
    })()
  );
};

const performCTest = () => {
  return runProgram(
    (function*() {
      yield main(function*() {
        return yield performEffect(yield EffectC());
      });
    })()
  );
};

const performDTest = input => {
  return runProgram(
    (function*() {
      yield main(function*() {
        return yield performEffect(yield EffectD(input));
      });
    })()
  );
};

const performAllTest = () => {
  return runProgram(
    (function*() {
      yield main(function*() {
        return \`\${yield performEffect(
          yield EffectA()
        )}\${yield performEffect(yield EffectB())}\${yield performEffect(yield EffectC())}\`;
      });
    })()
  );
};

module.exports.test = ({ it, describe, expect, code }) => {
  describe("Single effect", () => {
    it("Should perform effect A", async () => {
      const result = await performATest();
      expect(result).toBe(effectTypeA);
    });
    it("Should perform effect B", async () => {
      const result = await performBTest();
      expect(result).toBe(effectTypeB);
    });
    it("Should perform effect C", async () => {
      const result = await performCTest();
      expect(result).toBe(effectTypeC);
    });
  });
  describe("Overlapping recall statements", () => {
    it("Should perform recall functions referenced in multiple places without cause", async () => {
      const resultA = await performDTest(1);
      const resultB = await performDTest(2);
      const resultC = await performDTest(3);
      const bazinga = await performDTest("bazinga");
      expect(resultA).toBe(effectTypeA);
      expect(resultB).toBe(effectTypeB);
      expect(resultC).toBe(effectTypeC);
      expect(bazinga).toBe("bazinga");
    });
  });
  it("Should handle all cases", async () => {
    const result = await performAllTest();
    expect(result).toBe(\`\${effectTypeA}\${effectTypeB}\${effectTypeC}\`);
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS computed-handlers.js: computed-handlers.js 1`] = `

const symbolHandler = Symbol();
const {computedHandler} = {};

const main = async (fn) => {
    try{
        return fn();
    }handle symbolHandler with (_) {
        recall 'symbol';
    }handle computedHandler with (_){
        recall 'computed';
    }
};

const performSymbolHandler = async () => {
    'use effects';
    main(() => {
        return perform {type : symbolHandler}
    });
};

const performComputedHandler = async () => {
    'use effects';
    main(() => {
        return perform {type : computedHandler}
    })
};

const locallyScopedEffects = async () => {
  'use effects';
  const something = 'something';
  try{
      return perform {type : something};
  }handle something with (_){
      recall something;
  }
};

module.exports.test = ({describe, it, code, expect}) => {
    describe(\`Computed props for effects handlers\`, () => {
        it('Should behave as expected when performing a symbol handler', async () => {
            await expect(performSymbolHandler()).resolves.toBe('symbol');
        });

        it('Should behave as expected when performing a computed handler', async () => {
            await expect(performComputedHandler()).resolves.toBe('computed');
        });

        it('Should handle locally scoped effect types', async () => {
            await expect(locallyScopedEffects()).resolves.toBe('something');
        })
    });
};

      ↓ ↓ ↓ ↓ ↓ ↓

const symbolHandler = Symbol();
const { computedHandler } = {};

const main = async function*(fn) {
  return yield withHandler(
    {
      *[symbolHandler](_, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              return stackResume(handler, "symbol")
                .then(res)
                .catch(rej);
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      },

      *[computedHandler](_, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              return stackResume(handler, "computed")
                .then(res)
                .catch(rej);
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      }
    },
    (async function*() {
      return yield fn();
    })()
  );
};

const performSymbolHandler = async () => {
  return runProgram(
    (function*() {
      yield main(function*() {
        return yield performEffect({
          type: symbolHandler
        });
      });
    })()
  );
};

const performComputedHandler = async () => {
  return runProgram(
    (function*() {
      yield main(function*() {
        return yield performEffect({
          type: computedHandler
        });
      });
    })()
  );
};

const locallyScopedEffects = async () => {
  return runProgram(
    (function*() {
      const something = "something";
      yield withHandler(
        {
          *[something](_, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, something)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield performEffect({
            type: something
          });
        })()
      );
    })()
  );
};

module.exports.test = ({ describe, it, code, expect }) => {
  describe(\`Computed props for effects handlers\`, () => {
    it("Should behave as expected when performing a symbol handler", async () => {
      await expect(performSymbolHandler()).resolves.toBe("symbol");
    });
    it("Should behave as expected when performing a computed handler", async () => {
      await expect(performComputedHandler()).resolves.toBe("computed");
    });
    it("Should handle locally scoped effect types", async () => {
      await expect(locallyScopedEffects()).resolves.toBe("something");
    });
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS concurrent-async-identity.js: concurrent-async-identity.js 1`] = `

const delay = ms => new Promise(res => setTimeout(res, ms))
const asyncIdentity = name => {
  return perform { type: 'async_identity', payload: { name } }
}

const work = async (name) => {
  'use effects'
  try {
    return asyncIdentity(name)
  } handle 'async_identity' with (e) {
    const { payload: { name } } = e
    await delay(name === 'a' ? 100 : 1)
    recall name
  }
}

function main () {
  const aP = work('a')
  const bP = work('b')
  const cP = work('c')
  return Promise.all([aP, bP, cP])
}

module.exports.test = ({it, expect}) => {
  it('Should return out-of-order, concurrent effect-roots back in called order', async () => {
    const result = await main();
    expect(result).toEqual(['a', 'b', 'c']);
  });
};

      ↓ ↓ ↓ ↓ ↓ ↓

const asyncIdentity = function*(name) {
  return yield performEffect({
    type: "async_identity",
    payload: {
      name
    }
  });
};

const work = async name => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *async_identity(e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const delay = ms => new Promise(res => setTimeout(res, ms));

                  const {
                    payload: { name }
                  } = e;
                  await delay(name === "a" ? 100 : 1);
                  return stackResume(handler, name)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield asyncIdentity(name);
        })()
      );
    })()
  );
};

function main() {
  const aP = work("a");
  const bP = work("b");
  const cP = work("c");
  return Promise.all([aP, bP, cP]);
}

module.exports.test = ({ it, expect }) => {
  it("Should return out-of-order, concurrent effect-roots back in called order", async () => {
    const result = await main();
    expect(result).toEqual(["a", "b", "c"]);
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS data-passing.js: data-passing.js 1`] = `

const main = () => {
    'use effects';
    try{
        return perform {type : 'effect', data : 'data'}
    }handle 'effect' with (e){
        recall e.data
    }
};

const dynamicEffect = (effect) => {
    'use effects';
    try{
        return perform effect;
    }handle 'effectA' with (e){
        recall 'effectA';
    }handle 'effectB' with (e){
        if(e.data === 1){
            recall true;
        } else {
            recall false;
        }
    }
}
module.exports.test = ({it, expect, code}) => {
    it('Should pass data into handler variable', async () => {
        const result = await main();

        expect(result).toBe('data');
    });

    it('Should respond to dynamic effect passing', async () => {
        const result = await dynamicEffect({type : 'effectA'});

        expect(result).toBe('effectA');
    });

    it('Should recall dynamically', async () => {
        const resultA = await dynamicEffect({type : 'effectB', data : 1});
        const resultB = await dynamicEffect({type : 'effectB', data : 2});

        expect(resultA).toBe(true);
        expect(resultB).toBe(false);
    })
};

      ↓ ↓ ↓ ↓ ↓ ↓

const main = () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *effect(e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, e.data)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield performEffect({
            type: "effect",
            data: "data"
          });
        })()
      );
    })()
  );
};

const dynamicEffect = effect => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *effectA(e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, "effectA")
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          },

          *effectB(e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  if (e.data === 1) {
                    return stackResume(handler, true)
                      .then(res)
                      .catch(rej);
                  } else {
                    return stackResume(handler, false)
                      .then(res)
                      .catch(rej);
                  }
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield performEffect(effect);
        })()
      );
    })()
  );
};

module.exports.test = ({ it, expect, code }) => {
  it("Should pass data into handler variable", async () => {
    const result = await main();
    expect(result).toBe("data");
  });
  it("Should respond to dynamic effect passing", async () => {
    const result = await dynamicEffect({
      type: "effectA"
    });
    expect(result).toBe("effectA");
  });
  it("Should recall dynamically", async () => {
    const resultA = await dynamicEffect({
      type: "effectB",
      data: 1
    });
    const resultB = await dynamicEffect({
      type: "effectB",
      data: 2
    });
    expect(resultA).toBe(true);
    expect(resultB).toBe(false);
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS default-handlers.js: default-handlers.js 1`] = `

const effectType = Symbol();

const main = async (data) => {
    'use effects';
  try{
      let result = perform {type: effectType, data};
      result += perform {data : result};

      return result;
  } handle effectType with ({data}){
      recall (data + 1);
  } handle default with ({data}){
      recall (data * 2);
  }
};


module.exports.test = ({it, expect, code}) => {
    it('Should handle a non-explicitly declared effect when a default effect handler when present', async () => {
        const result = await main(1);

        expect(result).toBe(6);
    });
};

      ↓ ↓ ↓ ↓ ↓ ↓

const effectType = Symbol();

const main = async data => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[effectType]({ data }, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, data + 1)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          },

          *[__defaultEffectHandler__]({ data }, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, data * 2)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          let result = yield performEffect({
            type: effectType,
            data
          });
          result += yield performEffect({
            data: result
          });
          return result;
        })()
      );
    })()
  );
};

module.exports.test = ({ it, expect, code }) => {
  it("Should handle a non-explicitly declared effect when a default effect handler when present", async () => {
    const result = await main(1);
    expect(result).toBe(6);
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS destructure.js: destructure.js 1`] = `

const typeDestructure = () => {
    'use effects';
    try{
        return perform {type : 'sayHi'};
    }handle 'sayHi' with (e){
        recall 'Hello :)'
    }
};

const propDestructure = (mutableThing) => {
    'use effects';
    try{
        mutableThing += perform {type : 'addOne', data : mutableThing};
        mutableThing += perform {type : 'addTwo', data : mutableThing};

        return mutableThing;
    }handle 'addOne' with ({data}) {
        recall(data + 1);
    }handle 'addTwo' with ({data}) {
        recall(data + 2);
    }
};

const deepPropDestructuring = (propValue) => {
    'use effects'
    try{
        return perform {
            type : 'a',
            payload : {
                a : {
                    b : propValue
                }
            }
        }
    }handle 'a' with ({payload : {a : { b }}}){
        recall b
    }
};

const restDestructure = () => {
  'use effects'
  try{
      return perform {type : 'example', data1 : 'example 1 data 1', data2 : 'example 1 data 2'}
  } handle 'example' with ({...data}){
      const {data1, data2} = data;
      recall [data1, data2];
  }
};

const defaultAssignments = () => {
    'use effects';
    try{
        return perform {type : 'getDefault'};
    }handle 'getDefault' with ({data = "default"}){
        recall data;
    }
};

module.exports.test = ({it, expect, describe, code}) => {
    describe('Destructuring effects handlers', () => {
        it('Should destructure effect types in handle block', async () => {
            const result = await typeDestructure();

            expect(result).toBe('Hello :)');
        });

        it('Should destructure props from performed effects', async () => {
            const result = await propDestructure(0);
           expect(result).toBe(4);
        });

        it('Should destructure deep props from performed effects', async () => {
            const expectedResult = 'such deep prop very wow';
            const result = await deepPropDestructuring(expectedResult);

            expect(result).toBe(expectedResult);

        });

        it('Should handle rest props correctly during the destructure', async () =>{
            const [data1, data2] = await restDestructure();

            expect(data1).toBe('example 1 data 1');
            expect(data2).toBe('example 1 data 2');
        });

        it('Should handle default destructure props', async () => {
            const result = await defaultAssignments()

            expect(result).toBe('default');
        });
    });
};

      ↓ ↓ ↓ ↓ ↓ ↓

const typeDestructure = () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *sayHi(e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, "Hello :)")
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield performEffect({
            type: "sayHi"
          });
        })()
      );
    })()
  );
};

const propDestructure = mutableThing => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *addOne({ data }, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, data + 1)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          },

          *addTwo({ data }, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, data + 2)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          mutableThing += yield performEffect({
            type: "addOne",
            data: mutableThing
          });
          mutableThing += yield performEffect({
            type: "addTwo",
            data: mutableThing
          });
          return mutableThing;
        })()
      );
    })()
  );
};

const deepPropDestructuring = propValue => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *a(
            {
              payload: {
                a: { b }
              }
            },
            resume
          ) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, b)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield performEffect({
            type: "a",
            payload: {
              a: {
                b: propValue
              }
            }
          });
        })()
      );
    })()
  );
};

const restDestructure = () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *example({ ...data }, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const { data1, data2 } = data;
                  return stackResume(handler, [data1, data2])
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield performEffect({
            type: "example",
            data1: "example 1 data 1",
            data2: "example 1 data 2"
          });
        })()
      );
    })()
  );
};

const defaultAssignments = () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *getDefault({ data = "default" }, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, data)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield performEffect({
            type: "getDefault"
          });
        })()
      );
    })()
  );
};

module.exports.test = ({ it, expect, describe, code }) => {
  describe("Destructuring effects handlers", () => {
    it("Should destructure effect types in handle block", async () => {
      const result = await typeDestructure();
      expect(result).toBe("Hello :)");
    });
    it("Should destructure props from performed effects", async () => {
      const result = await propDestructure(0);
      expect(result).toBe(4);
    });
    it("Should destructure deep props from performed effects", async () => {
      const expectedResult = "such deep prop very wow";
      const result = await deepPropDestructuring(expectedResult);
      expect(result).toBe(expectedResult);
    });
    it("Should handle rest props correctly during the destructure", async () => {
      const [data1, data2] = await restDestructure();
      expect(data1).toBe("example 1 data 1");
      expect(data2).toBe("example 1 data 2");
    });
    it("Should handle default destructure props", async () => {
      const result = await defaultAssignments();
      expect(result).toBe("default");
    });
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS errors-in-handlers.js: errors-in-handlers.js 1`] = `

const ejectType = 'throwErrorHandler';
const EjectEffect = () => ({type : ejectType});


const syncEject = () => {
    throw new Error('eject');
};

const asyncEject = async () => {
    await new Promise((res) => {
        setTimeout(res, 10)
    });

    throw new Error('eject');
};

const continuationEject = () => {
    setTimeout(() => {
        throw new Error('eject');
    }, 10);
};

const syncEjectCase = () => {
    'use effects';
    try{
        perform EjectEffect();
    }handle ejectType with (e){
        syncEject();
    }
};

const asyncEjectCase = async () => {
    'use effects';
    try{
        perform EjectEffect();
    }handle ejectType with (e){
        await asyncEject();
    }
};

const continuationEjectCase = () => {
  'use effects';
  try{

  }handle ejectType with (e){
      continuationEject();
  }
};

module.exports.test = async ({it, expect, code}) => {
    it('Should handle errors as expected when effect handlers throw', async() => {
        await expect(syncEjectCase()).rejects.toThrowError('eject');
    });

    it('Should handle errors as expected when effect handlers are async and throw', async () => {
        await expect(asyncEjectCase()).rejects.toThrowError('eject');
    });

    it.skip('Should handle errors as expected when effect handlers are async and throw', async () => {
        await expect(continuationEjectCase()).rejects.toThrowError('eject');
    });
};

      ↓ ↓ ↓ ↓ ↓ ↓

const ejectType = "throwErrorHandler";

const EjectEffect = () => ({
  type: ejectType
});

const syncEjectCase = () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[ejectType](e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const syncEject = () => {
                    throw new Error("eject");
                  };

                  syncEject();
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          yield performEffect(EjectEffect());
        })()
      );
    })()
  );
};

const asyncEjectCase = async () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[ejectType](e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const asyncEject = async () => {
                    await new Promise(res => {
                      setTimeout(res, 10);
                    });
                    throw new Error("eject");
                  };

                  await asyncEject();
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          yield performEffect(EjectEffect());
        })()
      );
    })()
  );
};

const continuationEjectCase = () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[ejectType](e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const continuationEject = () => {
                    setTimeout(() => {
                      throw new Error("eject");
                    }, 10);
                  };

                  continuationEject();
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {})()
      );
    })()
  );
};

module.exports.test = async ({ it, expect, code }) => {
  it("Should handle errors as expected when effect handlers throw", async () => {
    await expect(syncEjectCase()).rejects.toThrowError("eject");
  });
  it("Should handle errors as expected when effect handlers are async and throw", async () => {
    await expect(asyncEjectCase()).rejects.toThrowError("eject");
  });
  it.skip("Should handle errors as expected when effect handlers are async and throw", async () => {
    await expect(continuationEjectCase()).rejects.toThrowError("eject");
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS hello-world-multi-perform.js: hello-world-multi-perform.js 1`] = `

function main () {
  'use effects'
  try {
    return getMessage({
      population: 7700000000
    })
  } handle 'get_greeting' with (evt) {
    recall 'Hello'
  } handle 'get_audience' with (evt) {
    const { payload: population } = evt
    if (population > 7e7) recall 'world'
    else if (population > 1) recall 'friends'
    else if (population === 1) recall 'friend'
    else recall 'no one'
  }
}

function getMessage ({ population }) {
  const greeting = perform { type: 'get_greeting' }
  return \`\${greeting}, \${getAudience(population)}!\`
}

function getAudience (population) {
  return perform { type: 'get_audience', payload: population }
}

module.exports.test = ({it, expect}) => {
  it('Should create hello-world from multiple-performs', async () => {
      const result = await main();
      expect(result).toBe('Hello, world!');
  });
};

      ↓ ↓ ↓ ↓ ↓ ↓

function main() {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *get_greeting(evt, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, "Hello")
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          },

          *get_audience(evt, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const { payload: population } = evt;
                  if (population > 7e7)
                    return stackResume(handler, "world")
                      .then(res)
                      .catch(rej);
                  else if (population > 1)
                    return stackResume(handler, "friends")
                      .then(res)
                      .catch(rej);
                  else if (population === 1)
                    return stackResume(handler, "friend")
                      .then(res)
                      .catch(rej);
                  else
                    return stackResume(handler, "no one")
                      .then(res)
                      .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return yield yield getMessage({
            population: 7700000000
          });
        })()
      );
    })()
  );
}

function* getMessage({ population }) {
  const greeting = yield performEffect({
    type: "get_greeting"
  });
  return \`\${greeting}, \${yield getAudience(population)}!\`;
}

function* getAudience(population) {
  return yield performEffect({
    type: "get_audience",
    payload: population
  });
}

module.exports.test = ({ it, expect }) => {
  it("Should create hello-world from multiple-performs", async () => {
    const result = await main();
    expect(result).toBe("Hello, world!");
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS inline-arrow-function.js: inline-arrow-function.js 1`] = `

const performAThing = (type, props) => perform {type, ...props};

const recallAThing = (dataToRecall) => recall dataToRecall;

const inlineChildMethod = () => performAThing('childPerform', {data : 'performed from child'});

const root = (e, data) => {
    'use effects'
    try{
        if(typeof e === 'undefined'){
            return inlineChildMethod();
        }

        return performAThing(e, {data});

    }handle e with ({data}){
        if(data === 'functionalRecall') return recallAThing(data);

        recall data
    }handle 'childPerform' with (e){
        recall e;
    }
};

const main = async (e, data) => root(e, data);



module.exports.test = ({it, expect, code}) => {
    it('Compiles and runs an inline arrow function expression that performs', async () => {
        const identity = await main('dynamic-effect', 'hello world');
        expect(identity).toBe('hello world');
    });

    it('Compiles and runs an inline arrow function expression that recalls', async () => {
        const identity = await main('anything', 'functionalRecall');
        expect(identity).toBe('functionalRecall');
    });

    it('Compiles and runs an inline arrow function that is a child method in the virtual stack', async () => {
        const identity = await main(undefined);
        expect(identity).toEqual({data : 'performed from child' });
    })
};

      ↓ ↓ ↓ ↓ ↓ ↓

const performAThing = function*(type, props) {
  return yield performEffect({
    type,
    ...props
  });
};

const inlineChildMethod = function*() {
  return yield performAThing("childPerform", {
    data: "performed from child"
  });
};

const root = (e, data) => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[e]({ data }, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const recallAThing = dataToRecall =>
                    stackResume(handler, dataToRecall)
                      .then(res)
                      .catch(rej);

                  if (data === "functionalRecall") return recallAThing(data);
                  return stackResume(handler, data)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          },

          *childPerform(e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, e)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          if (typeof e === "undefined") {
            return yield inlineChildMethod();
          }

          return yield performAThing(e, {
            data
          });
        })()
      );
    })()
  );
};

const main = async (e, data) => root(e, data);

module.exports.test = ({ it, expect, code }) => {
  it("Compiles and runs an inline arrow function expression that performs", async () => {
    const identity = await main("dynamic-effect", "hello world");
    expect(identity).toBe("hello world");
  });
  it("Compiles and runs an inline arrow function expression that recalls", async () => {
    const identity = await main("anything", "functionalRecall");
    expect(identity).toBe("functionalRecall");
  });
  it("Compiles and runs an inline arrow function that is a child method in the virtual stack", async () => {
    const identity = await main(undefined);
    expect(identity).toEqual({
      data: "performed from child"
    });
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS nesting-handlers.js: nesting-handlers.js 1`] = `

const mainEffectHandler = (input) => {
    try{
       return input()
    }handle 'main' with (e){
        recall {value : "main"}
    }
};

const childEffectHandler = (input) => {
    try{
        return input();
    }handle 'child' with (e){
        recall {value : "child"}
    }
};

const main = () => {
  "use effects"
  return mainEffectHandler(() => {
      const {value} = perform {type : "main"}

      const childEffectResult = childEffectHandler(() => {
         const {value} = perform {type : 'child'}

         return value;
      });

      return [value, childEffectResult];
  })
};

const throwsUnhandledEffectError = () => {
    "use effects"
  return mainEffectHandler(() => {
      const {value} = perform {type : "main"}

      const childEffectResult = childEffectHandler(() => {
          const {value} = perform {type : 'child'}

          return value;
      });

      const uhOh = perform {type : 'child'};

      return [value, childEffectResult];
  })
};


module.exports.test = ({it, expect}) => {
    it('Should handle the happy-path nested child', async () => {
        const result = await main();

        expect(result).toEqual(['main', 'child'])
    });

    it('Should throw if a parent calls an effect handled by a child function', async () => {
        await expect(throwsUnhandledEffectError()).rejects.toThrowError("Encountered an unhandled effect :child")
    });
};

      ↓ ↓ ↓ ↓ ↓ ↓

const mainEffectHandler = function*(input) {
  return yield withHandler(
    {
      *main(e, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              return stackResume(handler, {
                value: "main"
              })
                .then(res)
                .catch(rej);
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      }
    },
    (async function*() {
      return yield input();
    })()
  );
};

const childEffectHandler = function*(input) {
  return yield withHandler(
    {
      *child(e, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              return stackResume(handler, {
                value: "child"
              })
                .then(res)
                .catch(rej);
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      }
    },
    (async function*() {
      return yield input();
    })()
  );
};

const main = () => {
  return runProgram(
    (function*() {
      return yield mainEffectHandler(function*() {
        const { value } = yield performEffect({
          type: "main"
        });
        const childEffectResult = yield childEffectHandler(function*() {
          const { value } = yield performEffect({
            type: "child"
          });
          return value;
        });
        return [value, childEffectResult];
      });
    })()
  );
};

const throwsUnhandledEffectError = () => {
  return runProgram(
    (function*() {
      return yield mainEffectHandler(function*() {
        const { value } = yield performEffect({
          type: "main"
        });
        const childEffectResult = yield childEffectHandler(function*() {
          const { value } = yield performEffect({
            type: "child"
          });
          return value;
        });
        const uhOh = yield performEffect({
          type: "child"
        });
        return [value, childEffectResult];
      });
    })()
  );
};

module.exports.test = ({ it, expect }) => {
  it("Should handle the happy-path nested child", async () => {
    const result = await main();
    expect(result).toEqual(["main", "child"]);
  });
  it("Should throw if a parent calls an effect handled by a child function", async () => {
    await expect(throwsUnhandledEffectError()).rejects.toThrowError(
      "Encountered an unhandled effect :child"
    );
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS normal-functions.js: normal-functions.js 1`] = `

const mainEffectHandler = (input) => {
    try{
        return input()
    }handle 'main' with (e){
        recall {value : "main"}
    }
};

const ident = x => x;

const performer = () => {
    return perform {type : "main"};
};

const main = () => {
    "use effects"
    return mainEffectHandler(() => {
        const {value} = performer();

        return ident(value);
    })
};

module.exports.test = ({it, expect, code}) => {
    it('Should handle the happy-path nested child', async () => {
        const result = await main();

        expect(result).toEqual('main')
    });
};

      ↓ ↓ ↓ ↓ ↓ ↓

const mainEffectHandler = function*(input) {
  return yield withHandler(
    {
      *main(e, resume) {
        const result = yield function(handler) {
          return new Promise(async (res, rej) => {
            try {
              return stackResume(handler, {
                value: "main"
              })
                .then(res)
                .catch(rej);
            } catch (handlerError) {
              rej(handlerError);
            }
          });
        };
        return yield resume(result);
      }
    },
    (async function*() {
      return yield input();
    })()
  );
};

const ident = x => x;

const performer = function*() {
  return yield performEffect({
    type: "main"
  });
};

const main = () => {
  return runProgram(
    (function*() {
      return yield mainEffectHandler(function*() {
        const { value } = yield performer();
        return yield ident(value);
      });
    })()
  );
};

module.exports.test = ({ it, expect, code }) => {
  it("Should handle the happy-path nested child", async () => {
    const result = await main();
    expect(result).toEqual("main");
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS perform-async-get-integer-control-flow.js: perform-async-get-integer-control-flow.js 1`] = `

const getIntegerHandler = 'getInteger';

const GetIntegerEffect = () => ({type : getIntegerHandler});

const expectation = 5;

const main = async () => {
    'use effects';
    try{
        return await asyncChild();
    }handle getIntegerHandler with (e){
        recall expectation;
    }
};

const asyncChild = async () => {
    const a = perform GetIntegerEffect();
    const result = await Promise.resolve(a);

    return result;
};


module.exports.test = ({it, expect, code}) => {
  it('Should compile, and return expected results with an async effect handler', async () => {
      const result = await main();
      expect(result).toBe(expectation)
  })
};

      ↓ ↓ ↓ ↓ ↓ ↓

const getIntegerHandler = "getInteger";

const GetIntegerEffect = () => ({
  type: getIntegerHandler
});

const expectation = 5;

const main = async () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[getIntegerHandler](e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, expectation)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          return await (yield asyncChild());
        })()
      );
    })()
  );
};

const asyncChild = async function*() {
  const a = yield performEffect(yield GetIntegerEffect());
  const result = await (yield Promise.resolve(a));
  return result;
};

module.exports.test = ({ it, expect, code }) => {
  it("Should compile, and return expected results with an async effect handler", async () => {
    const result = await main();
    expect(result).toBe(expectation);
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS perform-async-get-integer-handler.js: perform-async-get-integer-handler.js 1`] = `

const getAsyncIntegerHandler = 'getAsyncInteger';

const GetAsyncIntegerEffect = () => ({type : getAsyncIntegerHandler});

const expectation = 5;

const main = ({onEffectComplete}) => {
    'use effects';
    try{
        const result = perform GetAsyncIntegerEffect();

        onEffectComplete(result);
    }handle getAsyncIntegerHandler with (e){
        setTimeout(() => {
            recall expectation;
        }, 50)
    }
};

module.exports = {
    main,
    expectation
};

      ↓ ↓ ↓ ↓ ↓ ↓

const getAsyncIntegerHandler = "getAsyncInteger";

const GetAsyncIntegerEffect = () => ({
  type: getAsyncIntegerHandler
});

const expectation = 5;

const main = ({ onEffectComplete }) => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[getAsyncIntegerHandler](e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  setTimeout(() => {
                    return stackResume(handler, expectation)
                      .then(res)
                      .catch(rej);
                  }, 50);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          const result = yield performEffect(GetAsyncIntegerEffect());
          yield onEffectComplete(result);
        })()
      );
    })()
  );
};

module.exports = {
  main,
  expectation
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS perform-get-integer.js: perform-get-integer.js 1`] = `

const getIntegerHandler = 'getInteger';

const GetIntegerEffect = () => ({type : getIntegerHandler});

const main = async () => {
    'use effects';
    try{
        const integer = perform GetIntegerEffect();

        return integer
    }handle getIntegerHandler with (e){
        recall 5;
    }
}

module.exports.test = ({it, expect, code}) => {
    it("Should compile, and return expected results", async () => {
        const result = await main();

        expect(result).toBe(5);
    })
};

      ↓ ↓ ↓ ↓ ↓ ↓

const getIntegerHandler = "getInteger";

const GetIntegerEffect = () => ({
  type: getIntegerHandler
});

const main = async () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[getIntegerHandler](e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, 5)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          const integer = yield performEffect(GetIntegerEffect());
          return integer;
        })()
      );
    })()
  );
};

module.exports.test = ({ it, expect, code }) => {
  it("Should compile, and return expected results", async () => {
    const result = await main();
    expect(result).toBe(5);
  });
};


`;

exports[`transformEffects Transform proposed effects keywords into working JS throwing-errors-from-timers.js: throwing-errors-from-timers.js 1`] = `

const gatherBananasEffectType = 'throwErrorHandler';
const GatherBananasEffect = () => ({type : gatherBananasEffectType});


const gatherBananasHandler = async () => {
    setTimeout(() => {
        recall "A Bunch Of Bananas";
    }, 1)
};

const main = async () => {
    'use effects';
    try{
        const someBananas = perform GatherBananasEffect();
        if(someBananas === 'A Bunch Of Bananas'){
            throw new Error('I wanted Plantains!');
        }
    }handle gatherBananasEffectType with (e){
        gatherBananasHandler();
    }

};

module.exports.test = async ({it, expect}) => {
    it('Should handle errors when effects recall from within a timer', async () => {
        await expect(main()).rejects.toThrowError('I wanted Plantains!');
    })
};

      ↓ ↓ ↓ ↓ ↓ ↓

const gatherBananasEffectType = "throwErrorHandler";

const GatherBananasEffect = () => ({
  type: gatherBananasEffectType
});

const main = async () => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[gatherBananasEffectType](e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const gatherBananasHandler = async () => {
                    setTimeout(() => {
                      return stackResume(handler, "A Bunch Of Bananas")
                        .then(res)
                        .catch(rej);
                    }, 1);
                  };

                  gatherBananasHandler();
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          const someBananas = yield performEffect(GatherBananasEffect());

          if (someBananas === "A Bunch Of Bananas") {
            throw new Error("I wanted Plantains!");
          }
        })()
      );
    })()
  );
};

module.exports.test = async ({ it, expect }) => {
  it("Should handle errors when effects recall from within a timer", async () => {
    await expect(main()).rejects.toThrowError("I wanted Plantains!");
  });
};


`;
