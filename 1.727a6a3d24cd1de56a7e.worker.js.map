{"version":3,"sources":["webpack://lib/../src/StackFrame.ts","webpack://lib/../src/mod.ts","webpack://lib/../src/util.ts","webpack://lib/../src/prelude-polyfill.ts","webpack://lib/../src/runtime.ts"],"names":[],"mappings":"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","file":"1.727a6a3d24cd1de56a7e.worker.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar ReturnFrame = Symbol(\"ReturnFrame\");\nvar HandlerReference = Symbol(\"HandlerReference\");\nvar RootContinuation = Symbol(\"RootContinuation\");\nexports.getHandler = function (frame, type, defaultType) {\n    if (defaultType === void 0) { defaultType = null; }\n    var _a;\n    var handler = frame[HandlerReference];\n    if (util_1.exists(handler)) {\n        // @ts-ignore\n        return util_1.exists(handler[type]) ? handler[type] : (_a = handler[defaultType]) !== null && _a !== void 0 ? _a : null;\n    }\n    return null;\n};\nexports.getReturnFrame = function (frame) { return frame[ReturnFrame]; };\nexports.isHandlerType = function (frame, type) {\n    if (!util_1.isIterator(frame))\n        return false;\n    return exports.getHandler(frame, type) !== null;\n};\nexports.addReturn = function (targetFrame, returnFrame) { return void (targetFrame[ReturnFrame] = returnFrame); };\nexports.addHandler = function (frame, handler) {\n    return void (frame[HandlerReference] = handler);\n};\nexports.setRootContinuation = function (fn) {\n    return void (fn[RootContinuation] = true);\n};\nexports.isRootContinuation = function (fn) {\n    return Boolean(fn[RootContinuation]);\n};\nexports.findHandlerFrame = function (frame, type, defaultType) {\n    if (defaultType === void 0) { defaultType = null; }\n    var frameWithHandler = frame;\n    while (util_1.exists(frameWithHandler) && !exports.isHandlerType(frameWithHandler, type)) {\n        if (util_1.exists(defaultType) && exports.isHandlerType(frameWithHandler, defaultType))\n            break;\n        frameWithHandler = exports.getReturnFrame(frameWithHandler);\n    }\n    if (!util_1.exists(frameWithHandler) || !util_1.isIterator(frameWithHandler))\n        return null;\n    return frameWithHandler;\n};\n//# sourceMappingURL=StackFrame.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar StackFrame_1 = require(\"./StackFrame\");\nvar util_1 = require(\"./util\");\nvar _frame = __importStar(require(\"./StackFrame\"));\nvar _util = __importStar(require(\"./util\"));\nexports.frame = _frame;\nexports.util = _util;\nvar UnhandledEffectError = /** @class */ (function (_super) {\n    __extends(UnhandledEffectError, _super);\n    function UnhandledEffectError(_a) {\n        var type = _a.type;\n        var _this = _super.call(this) || this;\n        _this.message = \"Encountered an unhandled effect :\" + String(type);\n        return _this;\n    }\n    return UnhandledEffectError;\n}(TypeError));\nexports.UnhandledEffectError = UnhandledEffectError;\nvar unwindStack = function (e, frame) {\n    // TODO: [major] construct an intelligible stack trace.\n    //  This might be done best with the help of a babel transform plugin\n    var root = frame;\n    while (util_1.exists(root) && !StackFrame_1.isRootContinuation(root)) {\n        root = StackFrame_1.getReturnFrame(root);\n    }\n    if (util_1.isContinuation(root))\n        root(e);\n    else\n        throw e;\n};\nexports.stackResume = function (gen, arg) { return __awaiter(void 0, void 0, void 0, function () {\n    var _a, value, done, returnFrame, e_1;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                if (!util_1.isIterator(gen)) {\n                    return [2 /*return*/, gen];\n                }\n                _b.label = 1;\n            case 1:\n                _b.trys.push([1, 15, , 16]);\n                return [4 /*yield*/, gen.next(arg)];\n            case 2:\n                _a = _b.sent(), value = _a.value, done = _a.done;\n                if (!!done) return [3 /*break*/, 9];\n                if (!util_1.isIterator(value)) return [3 /*break*/, 4];\n                StackFrame_1.addReturn(value, gen);\n                return [4 /*yield*/, exports.stackResume(value, null)];\n            case 3: return [2 /*return*/, _b.sent()];\n            case 4:\n                if (!util_1.isContinuation(value)) return [3 /*break*/, 6];\n                return [4 /*yield*/, value(gen)];\n            case 5: return [2 /*return*/, _b.sent()];\n            case 6: return [4 /*yield*/, exports.stackResume(gen, value)];\n            case 7: return [2 /*return*/, _b.sent()];\n            case 8: return [3 /*break*/, 14];\n            case 9:\n                returnFrame = StackFrame_1.getReturnFrame(gen);\n                if (!util_1.isIterator(returnFrame)) return [3 /*break*/, 11];\n                return [4 /*yield*/, exports.stackResume(returnFrame, value)];\n            case 10: return [2 /*return*/, _b.sent()];\n            case 11:\n                if (!util_1.isContinuation(returnFrame)) return [3 /*break*/, 13];\n                return [4 /*yield*/, returnFrame(value)];\n            case 12: return [2 /*return*/, _b.sent()];\n            case 13: return [2 /*return*/, arg];\n            case 14: return [3 /*break*/, 16];\n            case 15:\n                e_1 = _b.sent();\n                unwindStack(e_1, gen);\n                return [3 /*break*/, 16];\n            case 16: return [2 /*return*/];\n        }\n    });\n}); };\nexports.runProgram = function (root) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {\n    return [2 /*return*/, exports.stackResume(root, null)];\n}); }); };\nexports.performEffect = function (_a) {\n    var type = _a.type, data = __rest(_a, [\"type\"]);\n    return function (currentFrame) { return __awaiter(void 0, void 0, void 0, function () {\n        var frameWithEffectHandler, handlerFrameCreator, capturedContinuation, handlerFrame;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    frameWithEffectHandler = StackFrame_1.findHandlerFrame(currentFrame, type);\n                    if (!util_1.exists(frameWithEffectHandler)) {\n                        throw new UnhandledEffectError({ type: type });\n                    }\n                    handlerFrameCreator = StackFrame_1.getHandler(frameWithEffectHandler, type);\n                    // TODO: [minor] Set up a type-guard on getHandler, or findHandlerFrame to indicate that at this point the handlerFrame must exist.\n                    if (!util_1.exists(handlerFrameCreator)) {\n                        // Unreachable code\n                        throw new TypeError(\"Reached Something That shouldn't be reachable\");\n                    }\n                    capturedContinuation = function (handlerFnResult) {\n                        /**\n                         * The interpreter will call this with whatever frame is currently in control.\n                         * It's possible to do something with that frame.. but I don't think it's necessary,\n                         * just resume the frame that performed with the result of the perform.\n                         */\n                        return function (currentControlFrame) { return __awaiter(void 0, void 0, void 0, function () {\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, exports.stackResume(currentFrame, handlerFnResult)];\n                                    case 1: return [2 /*return*/, _a.sent()];\n                                }\n                            });\n                        }); };\n                    };\n                    handlerFrame = handlerFrameCreator(data, capturedContinuation);\n                    StackFrame_1.addReturn(handlerFrame, StackFrame_1.getReturnFrame(frameWithEffectHandler));\n                    return [4 /*yield*/, exports.stackResume(handlerFrame)];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    }); };\n};\nexports.withHandler = function (handler, frame) {\n    var handlerFrame = (function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, frame];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    })();\n    StackFrame_1.addHandler(handlerFrame, handler);\n    return handlerFrame;\n};\n//# sourceMappingURL=mod.js.map","\"use strict\";\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Helper method to lens a value as not null and not undefined\nexports.exists = function (x) {\n    return typeof x !== \"undefined\" && x !== null;\n};\n//  A Continuation is just a plain-old function.\n//  But the virtual stack interpreter checks to see if frames point to \"continuations\" which\n//  are plain old functions... helps the readability.\nexports.isContinuation = function (x) {\n    return typeof x === \"function\" &&\n        [\"AsyncGeneratorFunction\", \"GeneratorFunction\"].every(function (type) { return type !== Reflect.getPrototypeOf(x).constructor.name; });\n};\nexports.isIterator = function (x) {\n    return exports.exists(x) && exports.isContinuation(x.next);\n};\nvar asyncGeneratorInstance = function () { return __asyncGenerator(this, arguments, function () { return __generator(this, function (_a) {\n    return [2 /*return*/];\n}); }); };\nexports.isAsyncGenerator = function (input) {\n    return Reflect.getPrototypeOf(input) ===\n        Reflect.getPrototypeOf(asyncGeneratorInstance);\n};\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst runtime_1 = require(\"./runtime\");\nglobal.stackResume = runtime_1.stackResume;\nglobal.withHandler = runtime_1.withHandler;\nglobal.runProgram = runtime_1.runProgram;\nglobal.performEffect = runtime_1.performEffect;\nglobal.__defaultEffectHandler__ = runtime_1.DefaultEffectHandler;\n//# sourceMappingURL=prelude-polyfill.js.map","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common = __importStar(require(\"effects-common\"));\nconst { frame: { addHandler, addReturn, findHandlerFrame, getHandler, getReturnFrame, isRootContinuation }, util: { exists, isContinuation, isIterator } } = common;\nexports.DefaultEffectHandler = Symbol(\"DefaultEffectHandler\");\nclass UnhandledEffectError extends TypeError {\n    constructor({ type }) {\n        super();\n        this.message = `Encountered an unhandled effect :${String(type)}`;\n    }\n}\nexports.UnhandledEffectError = UnhandledEffectError;\nconst unwindStack = (e, frame) => {\n    let root = frame;\n    while (exists(root) && !isRootContinuation(root)) {\n        root = getReturnFrame(root);\n    }\n    if (isContinuation(root))\n        root(e);\n    else\n        throw e;\n};\nexports.stackResume = async (gen, arg) => {\n    if (!isIterator(gen)) {\n        return gen;\n    }\n    try {\n        const { value, done } = await gen.next(arg);\n        if (!done) {\n            if (isIterator(value)) {\n                addReturn(value, gen);\n                return await exports.stackResume(value, null);\n            }\n            else if (isContinuation(value)) {\n                return await value(gen);\n            }\n            else {\n                return await exports.stackResume(gen, value);\n            }\n        }\n        else {\n            const returnFrame = getReturnFrame(gen);\n            if (isIterator(returnFrame)) {\n                return await exports.stackResume(returnFrame, value);\n            }\n            else if (isContinuation(returnFrame)) {\n                return await returnFrame(value);\n            }\n            else {\n                return arg;\n            }\n        }\n    }\n    catch (e) {\n        unwindStack(e, gen);\n    }\n};\nexports.runProgram = async (root) => {\n    const result = await exports.stackResume(root, null);\n    return result;\n};\nexports.performEffect = ({ type, ...data }) => async (currentFrame) => {\n    const frameWithEffectHandler = findHandlerFrame(currentFrame, type, exports.DefaultEffectHandler);\n    if (!exists(frameWithEffectHandler)) {\n        throw new UnhandledEffectError({ type });\n    }\n    const handlerFrameCreator = getHandler(frameWithEffectHandler, type, exports.DefaultEffectHandler);\n    if (!exists(handlerFrameCreator)) {\n        throw new TypeError(`Reached Something That shouldn't be reachable`);\n    }\n    const capturedContinuation = (handlerFnResult) => async (currentControlFrame) => {\n        return await exports.stackResume(currentFrame, handlerFnResult);\n    };\n    const handlerFrame = handlerFrameCreator(data, capturedContinuation);\n    addReturn(handlerFrame, getReturnFrame(frameWithEffectHandler));\n    return await exports.stackResume(handlerFrame);\n};\nexports.withHandler = (handler, frame) => {\n    const handlerFrame = (function* () {\n        return yield frame;\n    })();\n    addHandler(handlerFrame, handler);\n    return handlerFrame;\n};\n//# sourceMappingURL=runtime.js.map"],"sourceRoot":""}