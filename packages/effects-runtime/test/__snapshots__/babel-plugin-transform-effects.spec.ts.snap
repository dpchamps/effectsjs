// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`transformEffects Transform proposed effects keywords into working JS inline-arrow-function.js: inline-arrow-function.js 1`] = `

const performAThing = (type, props) => perform {type, ...props};

const recallAThing = (dataToRecall) => recall dataToRecall;

const inlineChildMethod = () => performAThing('childPerform', {data : 'performed from child'});

const root = (e, data) => {
    'use effects'
    try{
        if(typeof e === 'undefined'){
            return inlineChildMethod();
        }

        return performAThing(e, {data});

    }handle e with ({data}){
        if(data === 'functionalRecall') return recallAThing(data);

        recall data
    }handle 'childPerform' with (e){
        recall e;
    }
};

const main = async (e, data) => root(e, data);



module.exports.test = ({it, expect, code}) => {
    it('Compiles and runs an inline arrow function expression that performs', async () => {
        const identity = await main('dynamic-effect', 'hello world');
        expect(identity).toBe('hello world');
    });

    it('Compiles and runs an inline arrow function expression that recalls', async () => {
        const identity = await main('anything', 'functionalRecall');
        expect(identity).toBe('functionalRecall');
    });

    it('Compiles and runs an inline arrow function that is a child method in the virtual stack', async () => {
        const identity = await main(undefined);
        expect(identity).toEqual({data : 'performed from child' });
    })
};

      ↓ ↓ ↓ ↓ ↓ ↓

const performAThing = function*(type, props) {
  return yield performEffect({
    type,
    ...props
  });
};

const inlineChildMethod = function*() {
  return yield performAThing("childPerform", {
    data: "performed from child"
  });
};

const root = (e, data) => {
  return runProgram(
    (function*() {
      yield withHandler(
        {
          *[e]({ data }, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  const recallAThing = dataToRecall =>
                    stackResume(handler, dataToRecall)
                      .then(res)
                      .catch(rej);

                  if (data === "functionalRecall") return recallAThing(data);
                  return stackResume(handler, data)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          },

          *childPerform(e, resume) {
            const result = yield function(handler) {
              return new Promise(async (res, rej) => {
                try {
                  return stackResume(handler, e)
                    .then(res)
                    .catch(rej);
                } catch (handlerError) {
                  rej(handlerError);
                }
              });
            };
            return yield resume(result);
          }
        },
        (async function*() {
          if (typeof e === "undefined") {
            return yield inlineChildMethod();
          }

          return yield performAThing(e, {
            data
          });
        })()
      );
    })()
  );
};

const main = async (e, data) => root(e, data);

module.exports.test = ({ it, expect, code }) => {
  it("Compiles and runs an inline arrow function expression that performs", async () => {
    const identity = await main("dynamic-effect", "hello world");
    expect(identity).toBe("hello world");
  });
  it("Compiles and runs an inline arrow function expression that recalls", async () => {
    const identity = await main("anything", "functionalRecall");
    expect(identity).toBe("functionalRecall");
  });
  it("Compiles and runs an inline arrow function that is a child method in the virtual stack", async () => {
    const identity = await main(undefined);
    expect(identity).toEqual({
      data: "performed from child"
    });
  });
};


`;
