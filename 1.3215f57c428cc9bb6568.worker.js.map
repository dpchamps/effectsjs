{"version":3,"sources":["webpack://lib/../src/EffectBoundary.ts","webpack://lib/../src/StackFrame.ts","webpack://lib/../src/mod.ts","webpack://lib/../src/util.ts","webpack://lib/../src/prelude-polyfill.ts","webpack://lib/../src/runtime.ts"],"names":[],"mappings":"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","file":"1.3215f57c428cc9bb6568.worker.js","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar StackFrame_1 = require(\"./StackFrame\");\nvar util_1 = require(\"./util\");\nvar validateIC = function (ic) {\n    return util_1.isContinuation(ic) || util_1.isGeneratorFactory(ic);\n};\nvar BoundaryError = /** @class */ (function (_super) {\n    __extends(BoundaryError, _super);\n    function BoundaryError(message) {\n        var _this = _super.call(this) || this;\n        _this.message = message;\n        Reflect.setPrototypeOf(_this, BoundaryError.prototype);\n        return _this;\n    }\n    return BoundaryError;\n}(Error));\nexports.BoundaryError = BoundaryError;\nvar getStackResumeFromContext = function (ctx) {\n    var _a;\n    var stackResume = (_a = global.stackResume) !== null && _a !== void 0 ? _a : ctx[\"stackResume\"];\n    if (!util_1.exists(stackResume)) {\n        throw new BoundaryError(\"Missing stackResume from context. Are you using Boundary without the Effects prelude-polyfill?\");\n    }\n    return stackResume;\n};\nvar maybeCreateFrame = function (ic) {\n    return util_1.isContinuation(ic)\n        ? function () {\n            var _i;\n            var args = [];\n            for (_i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, ic.apply(void 0, args)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        }\n        : ic;\n};\nexports.EffectBoundary = function () {\n    var ctxFn = function (ic) { return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (!validateIC(ic)) {\n            throw new BoundaryError(\"Must call boundary with a function or generator function\");\n        }\n        var unlink = function () { return StackFrame_1.addReturn(temporalFrame, null); };\n        var stackResume = getStackResumeFromContext(exports.EffectBoundary);\n        var temporalFrame = (function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, maybeCreateFrame(ic).apply(void 0, args)];\n                    case 1:\n                        _a.sent();\n                        unlink();\n                        return [2 /*return*/];\n                }\n            });\n        })();\n        StackFrame_1.addReturn(temporalFrame, StackFrame_1.getReturnFrame(ctxFn));\n        return stackResume(temporalFrame);\n    }; };\n    ctxFn.next = function () { return ({\n        value: ctxFn,\n        done: !!StackFrame_1.getReturnFrame(ctxFn),\n    }); };\n    return ctxFn;\n};\n//# sourceMappingURL=EffectBoundary.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar ReturnFrame = Symbol(\"ReturnFrame\");\nvar HandlerReference = Symbol(\"HandlerReference\");\nvar RootContinuation = Symbol(\"RootContinuation\");\nexports.getHandler = function (frame, type, defaultType) {\n    if (defaultType === void 0) { defaultType = null; }\n    var _a;\n    var handler = frame[HandlerReference];\n    if (util_1.exists(handler)) {\n        // @ts-ignore\n        return util_1.exists(handler[type]) ? handler[type] : (_a = handler[defaultType]) !== null && _a !== void 0 ? _a : null;\n    }\n    return null;\n};\nexports.getReturnFrame = function (frame) { return frame[ReturnFrame]; };\nexports.isHandlerType = function (frame, type) {\n    if (!util_1.isIterator(frame))\n        return false;\n    return exports.getHandler(frame, type) !== null;\n};\nexports.addReturn = function (targetFrame, returnFrame) { return void (targetFrame[ReturnFrame] = returnFrame); };\nexports.addHandler = function (frame, handler) {\n    return void (frame[HandlerReference] = handler);\n};\nexports.setRootContinuation = function (fn) {\n    return void (fn[RootContinuation] = true);\n};\nexports.isRootContinuation = function (fn) {\n    return Boolean(fn[RootContinuation]);\n};\nexports.findHandlerFrame = function (frame, type, defaultType) {\n    if (defaultType === void 0) { defaultType = null; }\n    var frameWithHandler = frame;\n    while (util_1.exists(frameWithHandler) && !exports.isHandlerType(frameWithHandler, type)) {\n        if (util_1.exists(defaultType) && exports.isHandlerType(frameWithHandler, defaultType))\n            break;\n        frameWithHandler = exports.getReturnFrame(frameWithHandler);\n    }\n    if (!util_1.exists(frameWithHandler) || !util_1.isIterator(frameWithHandler))\n        return null;\n    return frameWithHandler;\n};\n//# sourceMappingURL=StackFrame.js.map","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar StackFrame_1 = require(\"./StackFrame\");\nvar util_1 = require(\"./util\");\nvar _frame = __importStar(require(\"./StackFrame\"));\nvar _util = __importStar(require(\"./util\"));\nexports.frame = _frame;\nexports.util = _util;\nvar EffectBoundary_1 = require(\"./EffectBoundary\");\nexports.EffectBoundary = EffectBoundary_1.EffectBoundary;\nexports.BoundaryError = EffectBoundary_1.BoundaryError;\nvar UnhandledEffectError = /** @class */ (function (_super) {\n    __extends(UnhandledEffectError, _super);\n    function UnhandledEffectError(_a) {\n        var type = _a.type;\n        var _this = _super.call(this) || this;\n        _this.message = \"Encountered an unhandled effect :\" + String(type);\n        return _this;\n    }\n    return UnhandledEffectError;\n}(TypeError));\nexports.UnhandledEffectError = UnhandledEffectError;\nvar unwindStack = function (e, frame) {\n    // TODO: [major] construct an intelligible stack trace.\n    //  This might be done best with the help of a babel transform plugin\n    var root = frame;\n    while (util_1.exists(root) && !StackFrame_1.isRootContinuation(root)) {\n        root = StackFrame_1.getReturnFrame(root);\n    }\n    if (util_1.isContinuation(root))\n        root(e);\n    else\n        throw e;\n};\nexports.stackResume = function (gen, arg) { return __awaiter(void 0, void 0, void 0, function () {\n    var _a, value, done, returnFrame, e_1;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                if (!util_1.isIterator(gen)) {\n                    return [2 /*return*/, gen];\n                }\n                _b.label = 1;\n            case 1:\n                _b.trys.push([1, 15, , 16]);\n                return [4 /*yield*/, gen.next(arg)];\n            case 2:\n                _a = _b.sent(), value = _a.value, done = _a.done;\n                if (!!done) return [3 /*break*/, 9];\n                if (!util_1.isIterator(value)) return [3 /*break*/, 4];\n                StackFrame_1.addReturn(value, gen);\n                return [4 /*yield*/, exports.stackResume(value, null)];\n            case 3: return [2 /*return*/, _b.sent()];\n            case 4:\n                if (!util_1.isContinuation(value)) return [3 /*break*/, 6];\n                return [4 /*yield*/, value(gen)];\n            case 5: return [2 /*return*/, _b.sent()];\n            case 6: return [4 /*yield*/, exports.stackResume(gen, value)];\n            case 7: return [2 /*return*/, _b.sent()];\n            case 8: return [3 /*break*/, 14];\n            case 9:\n                returnFrame = StackFrame_1.getReturnFrame(gen);\n                if (!util_1.isIterator(returnFrame)) return [3 /*break*/, 11];\n                return [4 /*yield*/, exports.stackResume(returnFrame, value)];\n            case 10: return [2 /*return*/, _b.sent()];\n            case 11:\n                if (!util_1.isContinuation(returnFrame)) return [3 /*break*/, 13];\n                return [4 /*yield*/, returnFrame(value)];\n            case 12: return [2 /*return*/, _b.sent()];\n            case 13: return [2 /*return*/, arg];\n            case 14: return [3 /*break*/, 16];\n            case 15:\n                e_1 = _b.sent();\n                unwindStack(e_1, gen);\n                return [3 /*break*/, 16];\n            case 16: return [2 /*return*/];\n        }\n    });\n}); };\nexports.runProgram = function (root) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {\n    return [2 /*return*/, exports.stackResume(root, null)];\n}); }); };\nexports.performEffect = function (_a) {\n    var type = _a.type, data = __rest(_a, [\"type\"]);\n    return function (currentFrame) { return __awaiter(void 0, void 0, void 0, function () {\n        var frameWithEffectHandler, handlerFrameCreator, capturedContinuation, handlerFrame;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    frameWithEffectHandler = StackFrame_1.findHandlerFrame(currentFrame, type);\n                    if (!util_1.exists(frameWithEffectHandler)) {\n                        throw new UnhandledEffectError({ type: type });\n                    }\n                    handlerFrameCreator = StackFrame_1.getHandler(frameWithEffectHandler, type);\n                    // TODO: [minor] Set up a type-guard on getHandler, or findHandlerFrame to indicate that at this point the handlerFrame must exist.\n                    if (!util_1.exists(handlerFrameCreator)) {\n                        // Unreachable code\n                        throw new TypeError(\"Reached Something That shouldn't be reachable\");\n                    }\n                    capturedContinuation = function (handlerFnResult) {\n                        /**\n                         * The interpreter will call this with whatever frame is currently in control.\n                         * It's possible to do something with that frame.. but I don't think it's necessary,\n                         * just resume the frame that performed with the result of the perform.\n                         */\n                        return function (currentControlFrame) { return __awaiter(void 0, void 0, void 0, function () {\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0: return [4 /*yield*/, exports.stackResume(currentFrame, handlerFnResult)];\n                                    case 1: return [2 /*return*/, _a.sent()];\n                                }\n                            });\n                        }); };\n                    };\n                    handlerFrame = handlerFrameCreator(data, capturedContinuation);\n                    StackFrame_1.addReturn(handlerFrame, StackFrame_1.getReturnFrame(frameWithEffectHandler));\n                    return [4 /*yield*/, exports.stackResume(handlerFrame)];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    }); };\n};\nexports.withHandler = function (handler, frame) {\n    var handlerFrame = (function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, frame];\n                case 1: return [2 /*return*/, _a.sent()];\n            }\n        });\n    })();\n    StackFrame_1.addHandler(handlerFrame, handler);\n    return handlerFrame;\n};\n//# sourceMappingURL=mod.js.map","\"use strict\";\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Helper method to lens a value as not null and not undefined\nexports.exists = function (x) {\n    return typeof x !== \"undefined\" && x !== null;\n};\nexports.isGeneratorFactory = function (x) {\n    if (typeof x !== \"function\")\n        return false;\n    return [\"AsyncGeneratorFunction\", \"GeneratorFunction\"].some(function (type) { return type === Reflect.getPrototypeOf(x).constructor.name; });\n};\n//  A Continuation is just a plain-old function.\n//  But the virtual stack interpreter checks to see if frames point to \"continuations\" which\n//  are plain old functions... helps the readability.\nexports.isContinuation = function (x) {\n    return typeof x === \"function\" && !exports.isGeneratorFactory(x);\n};\nexports.isIterator = function (x) {\n    return exports.exists(x) && exports.isContinuation(x.next);\n};\nvar asyncGeneratorInstance = function () { return __asyncGenerator(this, arguments, function () { return __generator(this, function (_a) {\n    return [2 /*return*/];\n}); }); };\nexports.isAsyncGenerator = function (input) {\n    return Reflect.getPrototypeOf(input) ===\n        Reflect.getPrototypeOf(asyncGeneratorInstance);\n};\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst runtime_1 = require(\"./runtime\");\nglobal.stackResume = runtime_1.stackResume;\nglobal.withHandler = runtime_1.withHandler;\nglobal.runProgram = runtime_1.runProgram;\nglobal.performEffect = runtime_1.performEffect;\nglobal.__defaultEffectHandler__ = runtime_1.DefaultEffectHandler;\n//# sourceMappingURL=prelude-polyfill.js.map","\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst common = __importStar(require(\"effects-common\"));\nconst { frame: { addHandler, addReturn, findHandlerFrame, getHandler, getReturnFrame, }, util: { exists, isContinuation, isIterator }, } = common;\nexports.DefaultEffectHandler = Symbol(\"DefaultEffectHandler\");\nclass UnhandledEffectError extends TypeError {\n    constructor({ type }) {\n        super();\n        this.message = `Encountered an unhandled effect :${String(type)}`;\n    }\n}\nexports.UnhandledEffectError = UnhandledEffectError;\nconst unwindStack = async (e, frame) => {\n    const parent = getReturnFrame(frame);\n    if (isIterator(parent)) {\n        return await exports.stackResume(parent, e, true);\n    }\n    else if (isContinuation(parent)) {\n        return await parent(e);\n    }\n    else {\n        throw e;\n    }\n};\nexports.stackResume = async (gen, arg, willThrow) => {\n    if (!isIterator(gen)) {\n        return gen;\n    }\n    try {\n        const { value, done } = await (willThrow ? gen.throw(arg) : gen.next(arg));\n        if (!done) {\n            if (isIterator(value)) {\n                addReturn(value, gen);\n                return await exports.stackResume(value, null);\n            }\n            else if (isContinuation(value)) {\n                return await value(gen);\n            }\n            else {\n                return await exports.stackResume(gen, value);\n            }\n        }\n        else {\n            const returnFrame = getReturnFrame(gen);\n            if (isIterator(returnFrame)) {\n                return await exports.stackResume(returnFrame, value);\n            }\n            else if (isContinuation(returnFrame)) {\n                return await returnFrame(value);\n            }\n            else {\n                return arg;\n            }\n        }\n    }\n    catch (e) {\n        return await unwindStack(e, gen);\n    }\n};\nexports.runProgram = async (root) => exports.stackResume(root, null);\nexports.performEffect = ({ type, ...data }) => async (currentFrame) => {\n    const frameWithEffectHandler = findHandlerFrame(currentFrame, type, exports.DefaultEffectHandler);\n    if (!exists(frameWithEffectHandler)) {\n        return currentFrame.throw(new UnhandledEffectError({ type }));\n    }\n    const handlerFrameCreator = getHandler(frameWithEffectHandler, type, exports.DefaultEffectHandler);\n    if (!exists(handlerFrameCreator)) {\n        throw new TypeError(`Reached Something That shouldn't be reachable`);\n    }\n    const capturedContinuation = (handlerFnResult) => async (currentControlFrame) => {\n        return await exports.stackResume(currentFrame, handlerFnResult);\n    };\n    const handlerFrame = handlerFrameCreator(data, capturedContinuation);\n    addReturn(handlerFrame, getReturnFrame(frameWithEffectHandler));\n    return await exports.stackResume(handlerFrame);\n};\nexports.withHandler = (handler, frame) => {\n    const handlerFrame = (function* handlerFrame() {\n        return yield frame;\n    })();\n    addHandler(handlerFrame, handler);\n    return handlerFrame;\n};\n//# sourceMappingURL=runtime.js.map"],"sourceRoot":""}